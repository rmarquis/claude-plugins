# Command: implement-functional

Generate functional Kotlin implementation from specifications.

## Usage

```bash
/implement-functional <spec-or-module>
```

## Arguments

- `<spec-or-module>`: The specification name or module to implement
  - Can be a feature name (e.g., `user-auth`, `payment-processing`)
  - Can be a package name (e.g., `com.example.orders`)
  - Can be a partial name (will search for matches)

## Examples

```bash
# Implement from a feature specification
/implement-functional user-auth

# Implement a specific module
/implement-functional payment-processing

# Implement using package name
/implement-functional com.example.orders
```

## What This Command Does

1. **Locates Specifications**:
   - Searches `docs/specifications/<feature>/` for:
     - `contracts/<InterfaceName>ContractSpec.kt`
     - `behaviors/<FeatureName>BehaviorSpec.kt`
     - `properties/<TypeName>PropertySpec.kt`

2. **Locates Architecture Documentation**:
   - Searches `docs/architecture/<feature>.md`
   - Extracts module structure, responsibilities, and design decisions

3. **Analyzes Requirements**:
   - Extracts interface contracts from contract specs
   - Extracts acceptance criteria from behavior specs
   - Extracts invariants from property specs
   - Identifies domain models, value types, and error cases

4. **Generates Functional Implementation**:
   - **Domain Models**: Immutable data classes, sealed hierarchies, value classes
   - **Interfaces**: With comprehensive KDoc documenting contracts
   - **Pure Functions**: Business logic as pure, composable functions
   - **Error Handling**: Result types or sealed error hierarchies
   - **Extensions**: Domain operations as extension functions
   - **KDoc**: Comprehensive documentation with contracts, invariants, examples

5. **Outputs Code**:
   - Writes to `src/main/kotlin/<package>/`
   - Organizes into `domain/`, `contracts/`, `service/`, `extensions/` packages
   - Adds TODO comments for I/O operations (database, network, file system)

6. **Verifies Structure**:
   - Ensures generated interfaces match contract spec expectations
   - Validates that domain models satisfy property spec invariants

## Expected Directory Structure

### Input (Specifications)
```
docs/
└── specifications/
    └── user-auth/
        ├── contracts/
        │   └── UserRepositoryContractSpec.kt
        ├── behaviors/
        │   └── UserRegistrationBehaviorSpec.kt
        └── properties/
            └── UserPropertySpec.kt
```

### Input (Architecture)
```
docs/
└── architecture/
    └── user-auth.md
```

### Output (Implementation)
```
src/main/kotlin/com/example/userauth/
├── domain/
│   ├── User.kt                 # Immutable data class
│   ├── Email.kt                # Value class with validation
│   ├── Role.kt                 # Enum or sealed interface
│   └── RegistrationError.kt    # Sealed error hierarchy
├── contracts/
│   └── UserRepository.kt       # Interface with KDoc contracts
├── service/
│   ├── UserRegistration.kt     # Pure business logic functions
│   └── PasswordValidation.kt   # Pure validation functions
└── extensions/
    └── UserExtensions.kt       # Domain operations as extensions
```

## Generated Code Characteristics

### Immutability
- All properties are `val` (not `var`)
- All collections are immutable (`List`, `Map`, `Set`)
- State transformations use `copy()` or create new instances

### Expression-Oriented
- Prefer `when` expressions over `if` statements
- Single-expression functions where possible
- Minimal temporary variables

### Type-Safe Error Handling
- Use `Result<T>` for operations that can fail
- Sealed interfaces for domain-specific errors
- No exceptions for expected failures
- All failure modes documented in KDoc

### Comprehensive KDoc
Every public declaration includes:
- Summary and detailed description
- Preconditions (what must be true before calling)
- Postconditions (what is guaranteed after calling)
- Invariants (for classes)
- Side effects (if any)
- Examples (for complex APIs)
- Cross-references (`@see`)

### Functional Patterns
- Higher-order functions for behavior composition
- Extension functions for domain operations
- Lazy sequences for efficient transformations
- Scope functions for readable pipelines

### Pure Functions
- Business logic is pure (deterministic, no side effects)
- I/O operations marked with TODO comments
- Side effects isolated and documented

## Integration with Other Plugins

### With `software-specification`
- Reads kotlin-test specs generated by specification plugin
- Implements interfaces that contract specs test against
- Shares domain models between tests and implementation

### With `software-architecture`
- Uses module structure from architecture documentation
- Respects component boundaries and responsibilities
- Aligns with "deep modules" philosophy

## Options (Future)

The command may support additional options:

```bash
# Generate with specific style
/implement-functional user-auth --style=arrow  # Use Arrow library types

# Generate stubs only
/implement-functional user-auth --stubs-only

# Specify output package
/implement-functional user-auth --package=com.custom.auth
```

## Notes

- **Side Effects**: Generated code focuses on pure domain logic. I/O operations (database, network, file system) are marked with TODO comments for manual implementation.
- **Testing**: Generated code should be testable by contract specs from the specification plugin.
- **Incremental**: Safe to re-run on existing code—will offer to merge or update existing files.
- **Review**: Consider running `/review-functional` on generated code to verify quality.

## Success Criteria

Generated implementation should:
- ✅ Match interface contracts from specifications
- ✅ Satisfy property invariants from specifications
- ✅ Be 100% immutable (all `val` properties)
- ✅ Use Result types for all failure cases
- ✅ Have comprehensive KDoc on all public declarations
- ✅ Be expression-oriented (minimal statements)
- ✅ Have zero `!!` operators
- ✅ Be testable by contract specs

## Troubleshooting

**No specifications found:**
- Ensure specifications exist in `docs/specifications/<feature>/`
- Check feature name spelling
- Try using the full path

**Generated code doesn't compile:**
- Check TODO comments for missing implementations
- Verify package structure matches your project
- Ensure required dependencies are in build file

**Generated code doesn't match expectations:**
- Review architecture documentation for clarity
- Check contract specs for complete interface definitions
- Run `/review-functional` to identify improvements
